import { decodeFirst, decodeFirstSync, encode } from 'cbor';

/**
 * Data provided by the authenticator about the environment in which the
 * authentication took place in
 *
 * @property {string} rpIDHash base64-encoded SHA256 hash of the RP ID used during authentication
 * @property {AuthenticatorDataFlags} flags Bitfield of flags representing the user and registration
 * @property {number} useCount Number of times the credential was used
 * @property {AttestedCredentialData} attestedCredentialData The credential created during registration, if applicable
 */
type AuthenticatorData = {
  rpIDHash: string
  flags: AuthenticatorDataFlags
  useCount: number
  attestedCredentialData?: AttestedCredentialData
}

/**
 * Information about a credential
 *
 * @property {Buffer} authenticatorGuid A 128-bit identifier indicating the type and make of the authenticator
 * @property {string} credentialID The ID of this credential
 * @property {Buffer} credentialPubKey The public key generated by the authenticator
 */
type AttestedCredentialData = {
  authenticatorGuid: Buffer
  credentialID: Buffer
  credentialPubKey: Buffer
}

/**
 * Possible flags provided by the authenticator
 *
 * Flags are a one-byte bitfield, bit positions can be referenced
 * [here](https://www.w3.org/TR/webauthn-2/#flags)
 */
export enum AuthenticatorDataFlags {
  none,
  userPresent = 1 << 0,
  userVerified = 1 << 2,
  backupEligible = 1 << 3,
  backupState = 1 << 4,
  attestedCredIncluded = 1 << 6,
  extensionDataIncluded = 1 << 7
}

/**
 * Parse the encoded attestation data into usable data
 *
 * Based on https://w3c.github.io/webauthn/#attestation-object
 * @param bytes Buffer of encoded attestation data
 * @return An object representing various pieces of data in of the attestation data
 * @throws {Error} If the attestation data was invalid
 */
const parseAuthData = async (bytes: Buffer): Promise<AuthenticatorData> => {
  /*
    Don't bother parsing if there aren't enough bytes for at least:
     - rpIdHash (32 bytes)
     - flags (1 byte)
     - signCount (4 bytes)
   */
  if (bytes.byteLength < 37) throw new Error(
    `Received ${bytes.length} bytes but at least 37 are required to parse auth data`
  )

  let pt = 0; // Decoding pointer

  const rpIdHash = bytes.subarray(pt, (pt += 32)).toString('base64');

  const flags = bytes.subarray(pt, (pt += 1))[0];

  const counter = bytes.subarray(pt, (pt += 4)).readUInt32BE();

  let authData: AuthenticatorData = {
    rpIDHash: rpIdHash,
    flags: flags,
    useCount: counter
  }

  if (flags & AuthenticatorDataFlags.attestedCredIncluded) {
    const aGuid = bytes.subarray(pt, (pt += 16));

    const credIDLen = bytes.subarray(pt, (pt += 2)).readUInt16BE();
    const credentialID = bytes.subarray(pt, (pt += credIDLen));

    // Credential public key encoded in CBOR!
    // Decode the next CBOR item in the buffer, then re-encode it back to a Buffer to find the length of the CBOR-encoded public key
    const firstDecoded = decodeFirstSync(bytes.subarray(pt));
    const firstEncoded = Buffer.from(encode(firstDecoded) as ArrayBuffer);
    pt += firstEncoded.byteLength;

    authData.attestedCredentialData = {
      authenticatorGuid: aGuid,
      credentialID: credentialID,
      credentialPubKey: firstEncoded
    }
  }

  // Extensions: to be implemented if and when extensions are useful
  if (flags & AuthenticatorDataFlags.extensionDataIncluded) {
    const firstDecoded = decodeFirst(bytes.subarray(pt));
    const firstEncoded = Buffer.from(encode(firstDecoded) as ArrayBuffer);
   // extensionsData = decodeAuthenticatorExtensions(extensionsDataBuffer);
    pt += firstEncoded.byteLength;
  }

  // Pointer should be at the end of the authenticator data, otherwise too much data was sent
  if (bytes.byteLength > pt) throw new Error('Erroneous bytes present after decoding complete');

  return authData
}

export default parseAuthData